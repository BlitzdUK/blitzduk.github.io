<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>BlockCraft Puzzle</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #1e1e1e;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: manipulation;
    }
    h1 {
      margin: 10px;
      font-size: 1.5rem;
      color: #ffe799;
      text-align: center;
    }
    #game-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 10px;
    }
    #scoreContainer {
      display: flex;
      justify-content: space-around;
      width: 90vmin;
      margin-bottom: 10px;
    }
    .score-box {
      background: #333;
      padding: 8px 12px;
      border-radius: 6px;
      text-align: center;
      min-width: 80px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .score-label {
      font-size: 0.8rem;
      color: #aaa;
    }
    .score-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #ffe799;
    }
    #gameContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      width: 100%;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 2px;
      width: 90vmin;
      height: calc(90vmin * 1.5);
      background: #333;
      padding: 2px;
      border-radius: 6px;
      margin-bottom: 8px;
      position: relative;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    .cell {
      background: #444;
      width: 100%;
      aspect-ratio: 1;
      border-radius: 3px;
      transition: all 0.2s ease;
    }
    .filled {
      background: #fff;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
    }
    .ghost {
      position: absolute;
      opacity: 0.5;
      pointer-events: none;
      z-index: 10;
      transition: all 0.1s ease;
    }
    #pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      max-width: 90vmin;
      margin: 10px;
      touch-action: none;
    }
    .piece {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      width: 20vmin;
      touch-action: none;
      position: relative;
      transition: transform 0.1s;
    }
    .piece:active {
      transform: scale(1.05);
    }
    .block {
      border-radius: 3px;
      width: 100%;
      aspect-ratio: 1;
      transition: all 0.1s;
      box-shadow: 0 2px 3px rgba(0,0,0,0.3);
    }
    .animate-drop {
      animation: dropScale 0.3s ease-out;
    }
    @keyframes dropScale {
      0% { transform: scale(1.2); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    .animate-clear {
      animation: fadeOut 0.4s forwards;
    }
    @keyframes fadeOut {
      to { opacity: 0; transform: scale(0.8); }
    }
    .animate-line {
      animation: lineClear 0.6s;
    }
    @keyframes lineClear {
      0% { background-color: white; transform: scale(1); }
      30% { background-color: #ffe799; transform: scale(1.1); }
      100% { background-color: white; transform: scale(1); }
    }
    #controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 10px 0;
      width: 100%;
    }
    #dpad-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }
    #dpad {
      display: grid;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      gap: 8px;
    }
    .control-btn {
      width: 60px;
      height: 60px;
      background: #333;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 28px;
      color: #ffe799;
      user-select: none;
      cursor: pointer;
      border: none;
      outline: none;
      box-shadow: 0 3px 5px rgba(0,0,0,0.3);
      transition: all 0.1s;
    }
    .control-btn:active {
      background: #555;
      transform: scale(0.95);
    }
    #up {
      grid-area: up;
    }
    #left {
      grid-area: left;
    }
    #right {
      grid-area: right;
    }
    #down {
      grid-area: down;
    }
    #action-buttons {
      display: flex;
      gap: 15px;
    }
    .action-btn {
      width: 100px;
      height: 50px;
      background: #333;
      border-radius: 25px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      color: #ffe799;
      user-select: none;
      cursor: pointer;
      border: none;
      outline: none;
      box-shadow: 0 3px 5px rgba(0,0,0,0.3);
      transition: all 0.1s;
    }
    .action-btn:active {
      background: #555;
      transform: scale(0.95);
    }
    footer {
      font-size: 0.8rem;
      color: #ffe799;
      text-align: center;
      padding: 5px;
      margin-top: auto;
    }
    footer a {
      color: #ffe799;
      text-decoration: underline;
    }
  </style>
</head>
<body>

<div id="game-header">
  <h1>BlockCraft Puzzle</h1>
</div>
<div id="scoreContainer">
  <div class="score-box">
    <div class="score-label">Score</div>
    <div id="score" class="score-value">0</div>
  </div>
  <div class="score-box">
    <div class="score-label">Blocks</div>
    <div id="blocksPlaced" class="score-value">0</div>
  </div>
  <div class="score-box">
    <div class="score-label">Lines</div>
    <div id="linesCleared" class="score-value">0</div>
  </div>
</div>
<div id="gameContainer">
  <div id="board"></div>
  <div id="pieces"></div>
  <div id="controls">
    <div id="dpad-container">
      <div id="dpad">
        <button id="up" class="control-btn">↑</button>
        <button id="left" class="control-btn">←</button>
        <button id="right" class="control-btn">→</button>
        <button id="down" class="control-btn">↓</button>
      </div>
    </div>
    <div id="action-buttons">
      <button id="rotate-btn" class="action-btn">ROTATE</button>
      <button id="drop-btn" class="action-btn">DROP</button>
    </div>
  </div>
</div>
<footer>&copy; 2025 Blitzd Media. Contact: <a href="https://m.me/BlitzdMedia" target="_blank">m.me/BlitzdMedia</a></footer>

<script>
// Game Constants
const COLS = 10;
const ROWS = 15;
const CELL_COUNT = COLS * ROWS;
const SHAPES = [
  [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I
  [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]], // O
  [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // T
  [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // L
  [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // J
  [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]], // S
  [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]  // Z
];
const COLORS = ['#f5a623','#50e3c2','#f8e71c','#bd10e0','#7ed321','#ff3366','#4a90e2'];

// Game Elements
const board = document.getElementById('board');
const piecesContainer = document.getElementById('pieces');
const scoreDisplay = document.getElementById('score');
const blocksPlacedDisplay = document.getElementById('blocksPlaced');
const linesClearedDisplay = document.getElementById('linesCleared');
const upBtn = document.getElementById('up');
const leftBtn = document.getElementById('left');
const rightBtn = document.getElementById('right');
const downBtn = document.getElementById('down');
const rotateBtn = document.getElementById('rotate-btn');
const dropBtn = document.getElementById('drop-btn');

// Game State
let score = 0;
let blocksPlaced = 0;
let linesCleared = 0;
let cells = [];
let activePiece = null;

// Initialize the game board
function initBoard() {
  board.innerHTML = '';
  cells = [];
  
  for (let i = 0; i < CELL_COUNT; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.index = i;
    cells.push(cell);
    board.appendChild(cell);
  }
}

// Create a new piece
function createPiece(shapeIndex) {
  const shape = JSON.parse(JSON.stringify(SHAPES[shapeIndex]));
  const color = COLORS[shapeIndex];
  const pieceElement = document.createElement('div');
  pieceElement.className = 'piece';
  
  const positions = [];
  shape.forEach((row, y) => {
    row.forEach((val, x) => {
      const block = document.createElement('div');
      if (val) {
        block.className = 'block';
        block.style.background = color;
        positions.push({x, y});
      }
      pieceElement.appendChild(block);
    });
  });

  piecesContainer.appendChild(pieceElement);
  
  activePiece = {
    element: pieceElement,
    shape,
    color,
    positions,
    rotation: 0,
    x: 3,  // Default starting position
    y: 0,
    ghostElement: null
  };

  updateGhostPiece();
  setupPieceEventListeners();
}

// Update the ghost piece that shows where the active piece will land
function updateGhostPiece() {
  // Remove old ghost piece
  if (activePiece.ghostElement) {
    activePiece.ghostElement.remove();
  }

  // Calculate drop position
  let dropY = activePiece.y;
  while (isValidPosition(activePiece.x, dropY + 1, activePiece.shape)) {
    dropY++;
  }

  // Don't show ghost if piece is at bottom
  if (dropY === activePiece.y) return;

  // Create ghost piece
  const ghostElement = document.createElement('div');
  ghostElement.className = 'ghost';
  
  activePiece.shape.forEach((row, y) => {
    row.forEach((val, x) => {
      if (val) {
        const ghostBlock = document.createElement('div');
        ghostBlock.className = 'block';
        ghostBlock.style.background = activePiece.color;
        ghostBlock.style.opacity = '0.3';
        ghostBlock.style.position = 'absolute';
        ghostBlock.style.width = '100%';
        ghostBlock.style.height = '100%';
        ghostBlock.style.left = `${x * 100}%`;
        ghostBlock.style.top = `${y * 100}%`;
        ghostElement.appendChild(ghostBlock);
      }
    });
  });

  // Position ghost
  const cellIndex = dropY * COLS + activePiece.x;
  const cell = cells[cellIndex];
  const cellRect = cell.getBoundingClientRect();
  const boardRect = board.getBoundingClientRect();
  
  ghostElement.style.width = `${activePiece.element.offsetWidth}px`;
  ghostElement.style.height = `${activePiece.element.offsetHeight}px`;
  ghostElement.style.left = `${cellRect.left - boardRect.left}px`;
  ghostElement.style.top = `${cellRect.top - boardRect.top}px`;
  
  board.appendChild(ghostElement);
  activePiece.ghostElement = ghostElement;
}

// Check if a position is valid for the current piece
function isValidPosition(x, y, shape) {
  for (let row = 0; row < shape.length; row++) {
    for (let col = 0; col < shape[row].length; col++) {
      if (shape[row][col]) {
        const boardX = x + col;
        const boardY = y + row;
        
        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
          return false;
        }
        
        if (boardY >= 0) {
          const cellIndex = boardY * COLS + boardX;
          if (cells[cellIndex].classList.contains('filled')) {
            return false;
          }
        }
      }
    }
  }
  return true;
}

// Rotate the active piece
function rotatePiece() {
  if (!activePiece) return;

  // Create rotated shape
  const rotated = [];
  for (let col = 0; col < activePiece.shape[0].length; col++) {
    const newRow = [];
    for (let row = activePiece.shape.length - 1; row >= 0; row--) {
      newRow.push(activePiece.shape[row][col]);
    }
    rotated.push(newRow);
  }

  // Check if rotation is valid
  if (isValidPosition(activePiece.x, activePiece.y, rotated)) {
    activePiece.shape = rotated;
    activePiece.rotation = (activePiece.rotation + 1) % 4;
    
    // Update positions
    activePiece.positions = [];
    activePiece.shape.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val) activePiece.positions.push({x, y});
      });
    });

    // Update visual representation
    activePiece.element.innerHTML = '';
    activePiece.shape.forEach((row, y) => {
      row.forEach((val, x) => {
        const block = document.createElement('div');
        if (val) {
          block.className = 'block';
          block.style.background = activePiece.color;
        }
        activePiece.element.appendChild(block);
      });
    });

    updateGhostPiece();
  }
}

// Move the active piece
function movePiece(dx, dy) {
  if (!activePiece) return;

  const newX = activePiece.x + dx;
  const newY = activePiece.y + dy;
  
  if (isValidPosition(newX, newY, activePiece.shape)) {
    activePiece.x = newX;
    activePiece.y = newY;
    
    // Update visual position
    const cellIndex = newY * COLS + newX;
    const cell = cells[cellIndex];
    const cellRect = cell.getBoundingClientRect();
    const boardRect = board.getBoundingClientRect();
    
    activePiece.element.style.position = 'fixed';
    activePiece.element.style.left = `${cellRect.left - boardRect.left}px`;
    activePiece.element.style.top = `${cellRect.top - boardRect.top}px`;
    
    updateGhostPiece();
  }
}

// Drop the active piece to the lowest possible position
function dropPiece() {
  if (!activePiece) return;

  let newY = activePiece.y;
  while (isValidPosition(activePiece.x, newY + 1, activePiece.shape)) {
    newY++;
  }

  if (newY !== activePiece.y) {
    activePiece.y = newY;
    movePiece(0, 0); // Update visual position
    placePiece();
  }
}

// Place the active piece on the board
function placePiece() {
  if (!activePiece) return;

  // Place blocks on board
  activePiece.positions.forEach(pos => {
    const x = activePiece.x + pos.x;
    const y = activePiece.y + pos.y;
    
    if (y >= 0) { // Only place if on the board
      const index = y * COLS + x;
      cells[index].classList.add('filled');
      cells[index].style.background = activePiece.color;
      cells[index].classList.add('animate-drop');
      setTimeout(() => cells[index].classList.remove('animate-drop'), 300);
    }
  });

  blocksPlaced += activePiece.positions.length;
  score += activePiece.positions.length * 10;
  updateScore();

  // Remove active piece
  activePiece.element.remove();
  if (activePiece.ghostElement) {
    activePiece.ghostElement.remove();
  }
  activePiece = null;

  // Check for completed lines
  checkLines();
  
  // Generate new pieces if needed
  if (piecesContainer.children.length === 0) {
    generatePieces();
  }
}

// Check for completed lines and clear them
function checkLines() {
  let linesClearedThisTurn = 0;
  
  for (let y = ROWS - 1; y >= 0; y--) {
    const rowStart = y * COLS;
    const rowEnd = rowStart + COLS;
    const row = cells.slice(rowStart, rowEnd);
    
    if (row.every(cell => cell.classList.contains('filled'))) {
      linesClearedThisTurn++;
      
      // Animate line clear
      row.forEach(cell => {
        cell.classList.add('animate-line');
        setTimeout(() => {
          cell.classList.add('animate-clear');
          setTimeout(() => {
            cell.classList.remove('filled', 'animate-clear', 'animate-line');
            cell.style.background = '';
          }, 400);
        }, 100);
      });
    }
  }

  if (linesClearedThisTurn > 0) {
    linesCleared += linesClearedThisTurn;
    const lineBonus = [0, 100, 300, 500, 800][Math.min(linesClearedThisTurn, 4)];
    score += lineBonus;
    updateScore();

    // After animation, move blocks down
    setTimeout(() => {
      for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          const index = y * COLS + x;
          if (!cells[index].classList.contains('filled')) {
            // Find first filled block above
            for (let y2 = y - 1; y2 >= 0; y2--) {
              const indexAbove = y2 * COLS + x;
              if (cells[indexAbove].classList.contains('filled')) {
                // Move block down
                cells[index].classList.add('filled');
                cells[index].style.background = cells[indexAbove].style.background;
                cells[index].classList.add('animate-drop');
                setTimeout(() => cells[index].classList.remove('animate-drop'), 300);
                
                // Clear original position
                cells[indexAbove].classList.remove('filled');
                cells[indexAbove].style.background = '';
                break;
              }
            }
          }
        }
      }
    }, 600);
  }
}

// Generate new pieces
function generatePieces() {
  piecesContainer.innerHTML = '';
  
  // Create 3 random pieces
  for (let i = 0; i < 3; i++) {
    const shapeIndex = Math.floor(Math.random() * SHAPES.length);
    createPiece(shapeIndex);
  }
}

// Update score display
function updateScore() {
  scoreDisplay.textContent = score;
  blocksPlacedDisplay.textContent = blocksPlaced;
  linesClearedDisplay.textContent = linesCleared;
}

// Set up event listeners for the active piece
function setupPieceEventListeners() {
  if (!activePiece) return;

  let isDragging = false;
  let startX, startY;
  let startPieceX, startPieceY;

  // Touch events
  activePiece.element.addEventListener('touchstart', (e) => {
    e.preventDefault();
    isDragging = true;
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
    startPieceX = activePiece.x;
    startPieceY = activePiece.y;
  }, { passive: false });

  activePiece.element.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!isDragging) return;
    
    const touch = e.touches[0];
    const dx = touch.clientX - startX;
    const dy = touch.clientY - startY;
    
    // Convert pixel movement to grid movement
    const cellSize = board.offsetWidth / COLS;
    const gridDx = Math.round(dx / cellSize);
    const gridDy = Math.round(dy / cellSize);
    
    if (gridDx !== 0 || gridDy !== 0) {
      const newX = startPieceX + gridDx;
      const newY = startPieceY + gridDy;
      
      if (isValidPosition(newX, newY, activePiece.shape)) {
        activePiece.x = newX;
        activePiece.y = newY;
        movePiece(0, 0); // Update visual position
      }
    }
  }, { passive: false });

  activePiece.element.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (isDragging) {
      isDragging = false;
      placePiece();
    }
  }, { passive: false });

  // Button events
  upBtn.addEventListener('mousedown', () => movePiece(0, -1));
  leftBtn.addEventListener('mousedown', () => movePiece(-1, 0));
  rightBtn.addEventListener('mousedown', () => movePiece(1, 0));
  downBtn.addEventListener('mousedown', () => movePiece(0, 1));
  rotateBtn.addEventListener('mousedown', rotatePiece);
  dropBtn.addEventListener('mousedown', dropPiece);

  // Touch events for buttons
  upBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movePiece(0, -1); }, { passive: false });
  leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movePiece(-1, 0); }, { passive: false });
  rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movePiece(1, 0); }, { passive: false });
  downBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movePiece(0, 1); }, { passive: false });
  rotateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); rotatePiece(); }, { passive: false });
  dropBtn.addEventListener('touchstart', (e) => { e.preventDefault(); dropPiece(); }, { passive: false });
}

// Initialize the game
function initGame() {
  initBoard();
  generatePieces();
}

// Start the game
initGame();
</script>

</body>
</html>
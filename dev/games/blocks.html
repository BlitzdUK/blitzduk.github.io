<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>BlockCraft Puzzle</title>
<style>
  * { margin:0; padding:0; box-sizing: border-box; }
  body {
    font-family: sans-serif;
    background: #2e1c12;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    overflow: hidden;
  }
  h1 {
    color: #ffe799;
    margin: 10px;
  }
  #score {
    color: #fff0c0;
    margin-bottom: 10px;
    font-size: 1.2rem;
  }
  #board {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 2px;
    width: 90vmin;
    height: calc(90vmin * 1.6); /* 10x16 grid */
    background: #7a4f20;
    padding: 4px;
    border-radius: 8px;
  }
  .cell {
    background: #d2a679;
    width: 100%;
    aspect-ratio: 1;
    border-radius: 3px;
  }
  .filled {
    background: #fff;
  }
  #pieces {
    display: flex;
    gap: 12px;
    margin-top: 10px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 90vmin;
  }
  .piece {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 2px;
    width: 18vmin;
    touch-action: none;
  }
  .block {
    border-radius: 3px;
    width: 100%;
    aspect-ratio: 1;
  }
  .animate-clear {
    animation: fadeOut 0.4s forwards;
  }
  @keyframes fadeOut {
    to { opacity: 0; }
  }
  footer {
    position: absolute;
    bottom: 5px;
    font-size: 0.85rem;
    color: #ffe799;
    text-align: center;
    width: 100%;
  }
  footer a {
    color: #ffe799;
    text-decoration: underline;
  }
</style>
</head>
<body>
<h1>BlockCraft Puzzle</h1>
<div id="score">Score: 0</div>
<div id="board"></div>
<div id="pieces"></div>
<footer>&copy; 2025 Blitzd Media. Contact: <a href="https://m.me/BlitzdMedia" target="_blank">m.me/BlitzdMedia</a></footer>

<script>
const board = document.getElementById('board');
const piecesContainer = document.getElementById('pieces');
const scoreDisplay = document.getElementById('score');
let score = 0;
const cols = 10;
const rows = 16;
const totalCells = cols * rows;

// create grid cells
for (let i = 0; i < totalCells; i++) {
  const cell = document.createElement('div');
  cell.className = 'cell';
  cell.dataset.index = i;
  board.appendChild(cell);
}
const cells = Array.from(document.querySelectorAll('.cell'));

// Tetris-like shapes
const shapes = [
  [[0,0,0,0],
   [1,1,1,1],
   [0,0,0,0],
   [0,0,0,0]],
  [[0,1,1,0],
   [0,1,1,0],
   [0,0,0,0],
   [0,0,0,0]],
  [[0,1,0,0],
   [1,1,1,0],
   [0,0,0,0],
   [0,0,0,0]],
  [[0,0,1,0],
   [1,1,1,0],
   [0,0,0,0],
   [0,0,0,0]],
  [[1,0,0,0],
   [1,1,1,0],
   [0,0,0,0],
   [0,0,0,0]],
  [[0,1,1,0],
   [1,1,0,0],
   [0,0,0,0],
   [0,0,0,0]],
  [[1,1,0,0],
   [0,1,1,0],
   [0,0,0,0],
   [0,0,0,0]]
];

// color palette
const colors = ['#f5a623','#50e3c2','#f8e71c','#bd10e0','#7ed321','#ff3366','#4a90e2'];

// pick random color
function randomColor() {
  return colors[Math.floor(Math.random()*colors.length)];
}

// create draggable piece
function createPiece(shape) {
  const piece = document.createElement('div');
  piece.className = 'piece';
  const pieceColor = randomColor();
  let positions = [];

  shape.forEach((row, y)=>{
    row.forEach((val, x)=>{
      const block = document.createElement('div');
      if (val) {
        block.className = 'block';
        block.style.background = pieceColor;
        positions.push({x, y});
      }
      piece.appendChild(block);
    });
  });

  piecesContainer.appendChild(piece);

  let offsetX=0, offsetY=0;

  piece.addEventListener('touchstart', e=>{
    e.preventDefault();
    offsetX = e.touches[0].clientX - piece.getBoundingClientRect().left;
    offsetY = e.touches[0].clientY - piece.getBoundingClientRect().top;
    piece.style.position='fixed';
    piece.style.zIndex=1000;
  }, {passive:false});

  piece.addEventListener('touchmove', e=>{
    e.preventDefault();
    piece.style.left = (e.touches[0].clientX - offsetX)+'px';
    piece.style.top  = (e.touches[0].clientY - offsetY)+'px';
  }, {passive:false});

  piece.addEventListener('touchend', e=>{
    e.preventDefault();
    const dropX = e.changedTouches[0].clientX;
    const dropY = e.changedTouches[0].clientY;
    const targetCell = cells.find(cell => {
      const rect = cell.getBoundingClientRect();
      return dropX > rect.left && dropX < rect.right && dropY > rect.top && dropY < rect.bottom;
    });
    if (targetCell) {
      const startIndex = parseInt(targetCell.dataset.index);
      const startX = startIndex % cols;
      const startY = Math.floor(startIndex / cols);
      let canPlace = true;
      positions.forEach(pos => {
        const x = startX + pos.x;
        const y = startY + pos.y;
        if (x >= cols || y >= rows) canPlace = false;
        const idx = y*cols + x;
        if (cells[idx] && cells[idx].classList.contains('filled')) canPlace = false;
      });
      if (canPlace) {
        positions.forEach(pos => {
          const x = startX + pos.x;
          const y = startY + pos.y;
          const idx = y*cols + x;
          cells[idx].classList.add('filled');
          cells[idx].style.background = pieceColor;
        });
        score += positions.length*10;
        checkLines();
      }
    }
    piece.remove();
    if (piecesContainer.children.length===0) generatePieces();
  }, {passive:false});
}

function generatePieces() {
  piecesContainer.innerHTML = '';
  for (let i=0;i<3;i++) {
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    createPiece(shape);
  }
}

function checkLines() {
  for (let y=0; y<rows; y++) {
    const row = cells.slice(y*cols, y*cols+cols);
    if (row.every(cell=>cell.classList.contains('filled'))) {
      row.forEach(cell=>{
        cell.classList.add('animate-clear');
        setTimeout(()=>{
          cell.classList.remove('filled','animate-clear');
          cell.style.background='';
        },400);
      });
      score+=100;
    }
  }
  scoreDisplay.textContent = 'Score: ' + score;
}

document.addEventListener('touchstart', ()=>{}, {passive:false});
generatePieces();
</script>
</body>
</html>
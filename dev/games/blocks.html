<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>BlockCraft Puzzle</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
      background: #1e1e1e;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 10px;
      font-size: 1.5rem;
      color: #ffe799;
    }
    #scoreContainer {
      display: flex;
      justify-content: space-around;
      width: 90vmin;
      margin-bottom: 10px;
    }
    .score-box {
      background: #333;
      padding: 8px 12px;
      border-radius: 6px;
      text-align: center;
      min-width: 80px;
    }
    .score-label {
      font-size: 0.8rem;
      color: #aaa;
    }
    .score-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #ffe799;
    }
    #gameContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      width: 100%;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 2px;
      width: 90vmin;
      height: calc(90vmin * 1.5);
      background: #333;
      padding: 2px;
      border-radius: 6px;
      margin-bottom: 8px;
      position: relative;
    }
    .cell {
      background: #555;
      width: 100%;
      aspect-ratio: 1;
      border-radius: 3px;
      transition: transform 0.1s;
    }
    .filled {
      background: #fff;
    }
    .ghost {
      position: absolute;
      opacity: 0.4;
      pointer-events: none;
      z-index: 10;
    }
    #pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      max-width: 90vmin;
      margin: 5px;
      touch-action: none;
    }
    .piece {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      width: 18vmin;
      touch-action: none;
      position: relative;
    }
    .block {
      border-radius: 3px;
      width: 100%;
      aspect-ratio: 1;
      transition: transform 0.1s;
    }
    .animate-drop {
      animation: dropScale 0.3s ease-out;
    }
    @keyframes dropScale {
      0% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .animate-clear {
      animation: fadeOut 0.4s forwards;
    }
    @keyframes fadeOut {
      to { opacity: 0; transform: scale(0.8); }
    }
    .animate-line {
      animation: lineClear 0.4s;
    }
    @keyframes lineClear {
      0% { background-color: white; }
      50% { background-color: #ffe799; transform: scale(1.1); }
      100% { background-color: white; transform: scale(1); }
    }
    #controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    #dpad {
      display: grid;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      gap: 8px;
      margin-bottom: 10px;
    }
    .dpad-btn {
      width: 50px;
      height: 50px;
      background: #333;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: #ffe799;
      user-select: none;
      cursor: pointer;
    }
    .dpad-btn:active {
      background: #555;
    }
    #up {
      grid-area: up;
    }
    #left {
      grid-area: left;
    }
    #right {
      grid-area: right;
    }
    #down {
      grid-area: down;
    }
    #rotate-btn {
      width: 80px;
      height: 50px;
      background: #333;
      border-radius: 25px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      color: #ffe799;
      user-select: none;
      cursor: pointer;
      margin-top: 10px;
    }
    #rotate-btn:active {
      background: #555;
    }
    footer {
      font-size: 0.8rem;
      color: #ffe799;
      text-align: center;
      padding: 5px;
    }
    footer a {
      color: #ffe799;
      text-decoration: underline;
    }
  </style>
</head>
<body>

<h1>BlockCraft Puzzle</h1>
<div id="scoreContainer">
  <div class="score-box">
    <div class="score-label">Score</div>
    <div id="score" class="score-value">0</div>
  </div>
  <div class="score-box">
    <div class="score-label">Blocks</div>
    <div id="blocksPlaced" class="score-value">0</div>
  </div>
  <div class="score-box">
    <div class="score-label">Lines</div>
    <div id="linesCleared" class="score-value">0</div>
  </div>
</div>
<div id="gameContainer">
  <div id="board"></div>
  <div id="pieces"></div>
  <div id="controls">
    <div id="dpad">
      <div id="up" class="dpad-btn">↑</div>
      <div id="left" class="dpad-btn">←</div>
      <div id="right" class="dpad-btn">→</div>
      <div id="down" class="dpad-btn">↓</div>
    </div>
    <div id="rotate-btn">ROTATE</div>
  </div>
</div>
<footer>&copy; 2025 Blitzd Media. Contact: <a href="https://m.me/BlitzdMedia" target="_blank">m.me/BlitzdMedia</a></footer>

<script>
const board = document.getElementById('board');
const piecesContainer = document.getElementById('pieces');
const scoreDisplay = document.getElementById('score');
const blocksPlacedDisplay = document.getElementById('blocksPlaced');
const linesClearedDisplay = document.getElementById('linesCleared');

// Control buttons
const upBtn = document.getElementById('up');
const leftBtn = document.getElementById('left');
const rightBtn = document.getElementById('right');
const downBtn = document.getElementById('down');
const rotateBtn = document.getElementById('rotate-btn');

let score = 0;
let blocksPlaced = 0;
let linesCleared = 0;
const cols = 10;
const rows = 15;
const totalCells = cols * rows;

// Initialize board cells
for (let i = 0; i < totalCells; i++) {
  const cell = document.createElement('div');
  cell.className = 'cell';
  cell.dataset.index = i;
  board.appendChild(cell);
}
const cells = Array.from(document.querySelectorAll('.cell'));

const shapes = [
  [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I
  [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]], // O
  [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // T
  [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // L
  [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // J
  [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]], // S
  [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]  // Z
];
const colors = ['#f5a623','#50e3c2','#f8e71c','#bd10e0','#7ed321','#ff3366','#4a90e2'];

let activePiece = {
  element: null,
  shape: null,
  positions: [],
  color: '',
  rotation: 0,
  offsetX: 0,
  offsetY: 0,
  ghost: null,
  validPosition: null
};

function randomColor() {
  return colors[Math.floor(Math.random() * colors.length)];
}

function rotateMatrix(matrix) {
  const N = matrix.length;
  const rotated = Array(N).fill().map(() => Array(N).fill(0));
  
  for (let y = 0; y < N; y++) {
    for (let x = 0; x < N; x++) {
      rotated[x][N-1-y] = matrix[y][x];
    }
  }
  
  return rotated;
}

function createPiece(shape) {
  const piece = document.createElement('div');
  piece.className = 'piece';
  const color = randomColor();
  const positions = [];

  shape.forEach((row, y) => {
    row.forEach((val, x) => {
      const block = document.createElement('div');
      if (val) {
        block.className = 'block';
        block.style.background = color;
        positions.push({ x, y });
      }
      piece.appendChild(block);
    });
  });

  piecesContainer.appendChild(piece);

  // Set active piece
  activePiece = {
    element: piece,
    shape: JSON.parse(JSON.stringify(shape)),
    positions: [...positions],
    color,
    rotation: 0,
    offsetX: 0,
    offsetY: 0,
    ghost: null,
    validPosition: null
  };

  // Initialize ghost piece
  updateGhostPiece(piece.getBoundingClientRect().left + piece.offsetWidth/2, 
                  piece.getBoundingClientRect().top + piece.offsetHeight/2);

  // Add event listeners
  piece.addEventListener('touchstart', handleTouchStart, { passive: false });
  piece.addEventListener('touchmove', handleTouchMove, { passive: false });
  piece.addEventListener('touchend', handleTouchEnd, { passive: false });

  // Button events
  upBtn.addEventListener('mousedown', moveUp);
  leftBtn.addEventListener('mousedown', moveLeft);
  rightBtn.addEventListener('mousedown', moveRight);
  downBtn.addEventListener('mousedown', moveDown);
  rotateBtn.addEventListener('mousedown', rotateActivePiece);

  // Touch events for buttons
  upBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveUp(); }, { passive: false });
  leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft(); }, { passive: false });
  rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight(); }, { passive: false });
  downBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveDown(); }, { passive: false });
  rotateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); rotateActivePiece(); }, { passive: false });
}

function moveUp() {
  if (activePiece.element) {
    const rect = activePiece.element.getBoundingClientRect();
    updateGhostPiece(rect.left + rect.width/2, rect.top - 20);
    updateActivePiecePosition();
  }
}

function moveLeft() {
  if (activePiece.element) {
    const rect = activePiece.element.getBoundingClientRect();
    updateGhostPiece(rect.left - 20, rect.top + rect.height/2);
    updateActivePiecePosition();
  }
}

function moveRight() {
  if (activePiece.element) {
    const rect = activePiece.element.getBoundingClientRect();
    updateGhostPiece(rect.left + rect.width + 20, rect.top + rect.height/2);
    updateActivePiecePosition();
  }
}

function moveDown() {
  if (activePiece.element) {
    const rect = activePiece.element.getBoundingClientRect();
    updateGhostPiece(rect.left + rect.width/2, rect.top + rect.height + 20);
    updateActivePiecePosition();
  }
}

function rotateActivePiece() {
  if (!activePiece.element) return;

  // Rotate the shape
  const newShape = rotateMatrix(activePiece.shape);
  const newPositions = [];
  
  newShape.forEach((row, y) => {
    row.forEach((val, x) => {
      if (val) newPositions.push({ x, y });
    });
  });

  // Check if rotation is valid
  if (activePiece.validPosition) {
    const { startX, startY } = activePiece.validPosition;
    let canRotate = true;
    
    newPositions.forEach(pos => {
      const x = startX + pos.x;
      const y = startY + pos.y;
      if (x >= cols || y >= rows) canRotate = false;
      const idx = y * cols + x;
      if (cells[idx] && cells[idx].classList.contains('filled')) canRotate = false;
    });

    if (canRotate) {
      // Update active piece
      activePiece.shape = newShape;
      activePiece.positions = newPositions;
      activePiece.rotation = (activePiece.rotation + 1) % 4;

      // Update the visual piece
      const piece = activePiece.element;
      piece.innerHTML = '';
      
      newShape.forEach((row, y) => {
        row.forEach((val, x) => {
          const block = document.createElement('div');
          if (val) {
            block.className = 'block';
            block.style.background = activePiece.color;
          }
          piece.appendChild(block);
        });
      });

      // Update ghost piece
      const rect = piece.getBoundingClientRect();
      updateGhostPiece(rect.left + rect.width/2, rect.top + rect.height/2);
    }
  }
}

function updateActivePiecePosition() {
  if (activePiece.validPosition && activePiece.element) {
    const { startX, startY } = activePiece.validPosition;
    const cell = cells[startY * cols + startX];
    const boardRect = board.getBoundingClientRect();
    const cellRect = cell.getBoundingClientRect();
    
    activePiece.element.style.position = 'fixed';
    activePiece.element.style.left = (cellRect.left - boardRect.left + board.offsetLeft) + 'px';
    activePiece.element.style.top = (cellRect.top - boardRect.top + board.offsetTop) + 'px';
    activePiece.element.style.transform = 'translate(0, 0)';
  }
}

function handleTouchStart(e) {
  e.preventDefault();
  if (!activePiece.element) return;
  
  const rect = activePiece.element.getBoundingClientRect();
  activePiece.offsetX = e.touches[0].clientX - rect.left;
  activePiece.offsetY = e.touches[0].clientY - rect.top;
  activePiece.element.style.position = 'fixed';
  activePiece.element.style.zIndex = 1000;
  updateGhostPiece(e.touches[0].clientX, e.touches[0].clientY);
}

function handleTouchMove(e) {
  e.preventDefault();
  if (!activePiece.element) return;
  
  activePiece.element.style.left = (e.touches[0].clientX - activePiece.offsetX) + 'px';
  activePiece.element.style.top = (e.touches[0].clientY - activePiece.offsetY) + 'px';
  updateGhostPiece(e.touches[0].clientX, e.touches[0].clientY);
}

function handleTouchEnd(e) {
  e.preventDefault();
  placeActivePiece();
}

function updateGhostPiece(clientX, clientY) {
  // Remove previous ghost piece if exists
  if (activePiece.ghost) {
    activePiece.ghost.remove();
    activePiece.ghost = null;
  }

  const targetCell = cells.find(cell => {
    const rect = cell.getBoundingClientRect();
    return clientX > rect.left && clientX < rect.right && 
           clientY > rect.top && clientY < rect.bottom;
  });

  if (targetCell) {
    const startIndex = parseInt(targetCell.dataset.index);
    const startX = startIndex % cols;
    const startY = Math.floor(startIndex / cols);
    let canPlace = true;
    
    // Check if piece can be placed here
    activePiece.positions.forEach(pos => {
      const x = startX + pos.x;
      const y = startY + pos.y;
      if (x >= cols || y >= rows) canPlace = false;
      const idx = y * cols + x;
      if (cells[idx] && cells[idx].classList.contains('filled')) canPlace = false;
    });

    if (canPlace) {
      activePiece.validPosition = { startX, startY };
      activePiece.ghost = document.createElement('div');
      activePiece.ghost.className = 'ghost';
      activePiece.ghost.style.width = `${activePiece.element.offsetWidth}px`;
      activePiece.ghost.style.height = `${activePiece.element.offsetHeight}px`;
      activePiece.ghost.style.left = `${targetCell.getBoundingClientRect().left - board.getBoundingClientRect().left}px`;
      activePiece.ghost.style.top = `${targetCell.getBoundingClientRect().top - board.getBoundingClientRect().top}px`;
      
      // Create ghost blocks
      activePiece.shape.forEach((row, y) => {
        row.forEach((val, x) => {
          if (val) {
            const ghostBlock = document.createElement('div');
            ghostBlock.className = 'block';
            ghostBlock.style.background = activePiece.color;
            ghostBlock.style.opacity = '0.3';
            ghostBlock.style.position = 'absolute';
            ghostBlock.style.width = `${activePiece.element.children[0].offsetWidth}px`;
            ghostBlock.style.height = `${activePiece.element.children[0].offsetHeight}px`;
            ghostBlock.style.left = `${x * (activePiece.element.children[0].offsetWidth + 2)}px`;
            ghostBlock.style.top = `${y * (activePiece.element.children[0].offsetHeight + 2)}px`;
            activePiece.ghost.appendChild(ghostBlock);
          }
        });
      });
      
      board.appendChild(activePiece.ghost);
    }
  }
}

function placeActivePiece() {
  // Remove ghost piece
  if (activePiece.ghost) {
    activePiece.ghost.remove();
    activePiece.ghost = null;
  }

  if (activePiece.validPosition && activePiece.element) {
    const { startX, startY } = activePiece.validPosition;
    let canPlace = true;
    
    // Final check
    activePiece.positions.forEach(pos => {
      const x = startX + pos.x;
      const y = startY + pos.y;
      if (x >= cols || y >= rows) canPlace = false;
      const idx = y * cols + x;
      if (cells[idx] && cells[idx].classList.contains('filled')) canPlace = false;
    });

    if (canPlace) {
      // Place the piece with animation
      activePiece.positions.forEach(pos => {
        const x = startX + pos.x;
        const y = startY + pos.y;
        const idx = y * cols + x;
        cells[idx].classList.add('filled');
        cells[idx].style.background = activePiece.color;
        cells[idx].classList.add('animate-drop');
        setTimeout(() => {
          cells[idx].classList.remove('animate-drop');
        }, 300);
      });
      
      blocksPlaced += activePiece.positions.length;
      score += activePiece.positions.length * 10;
      updateScore();
      checkLines();
    }
  }
  
  // Clean up current piece
  if (activePiece.element) {
    activePiece.element.remove();
    activePiece.element = null;
  }
  
  // Remove button event listeners
  upBtn.removeEventListener('mousedown', moveUp);
  leftBtn.removeEventListener('mousedown', moveLeft);
  rightBtn.removeEventListener('mousedown', moveRight);
  downBtn.removeEventListener('mousedown', moveDown);
  rotateBtn.removeEventListener('mousedown', rotateActivePiece);
  
  // Generate new pieces if needed
  if (piecesContainer.children.length === 0) {
    generatePieces();
  }
}

function generatePieces() {
  piecesContainer.innerHTML = '';
  for (let i = 0; i < 3; i++) {
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    createPiece(shape);
  }
}

function checkLines() {
  let linesClearedThisTime = 0;
  
  for (let y = 0; y < rows; y++) {
    const row = cells.slice(y * cols, y * cols + cols);
    if (row.every(cell => cell.classList.contains('filled'))) {
      linesClearedThisTime++;
      row.forEach(cell => {
        cell.classList.add('animate-line');
        setTimeout(() => {
          cell.classList.add('animate-clear');
          setTimeout(() => {
            cell.classList.remove('filled', 'animate-clear', 'animate-line');
            cell.style.background = '';
          }, 400);
        }, 100);
      });
    }
  }
  
  if (linesClearedThisTime > 0) {
    linesCleared += linesClearedThisTime;
    const lineBonus = [0, 100, 300, 500, 800][Math.min(linesClearedThisTime, 4)];
    score += lineBonus;
    updateScore();
    
    // After clearing lines, shift blocks down
    setTimeout(() => {
      for (let y = rows - 1; y >= 0; y--) {
        for (let x = 0; x < cols; x++) {
          const idx = y * cols + x;
          if (!cells[idx].classList.contains('filled')) {
            // Find the first filled cell above this one
            for (let y2 = y - 1; y2 >= 0; y2--) {
              const idx2 = y2 * cols + x;
              if (cells[idx2].classList.contains('filled')) {
                // Move the block down
                cells[idx].classList.add('filled');
                cells[idx].style.background = cells[idx2].style.background;
                cells[idx].classList.add('animate-drop');
                setTimeout(() => {
                  cells[idx].classList.remove('animate-drop');
                }, 300);
                
                // Clear the original position
                cells[idx2].classList.remove('filled');
                cells[idx2].style.background = '';
                break;
              }
            }
          }
        }
      }
    }, 500);
  }
}

function updateScore() {
  scoreDisplay.textContent = score;
  blocksPlacedDisplay.textContent = blocksPlaced;
  linesClearedDisplay.textContent = linesCleared;
}

document.addEventListener('touchstart', () => { }, { passive: false });
generatePieces();
</script>

</body>
</html>
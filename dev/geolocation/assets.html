<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Blitzd Media Asset Tracking & Recovery</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #5259b8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Blitzd Media Asset Tracking & Recovery</p>
                        <p><h2><ins><strong>You must login to view the asset map</strong></ins></h2>

<p>&nbsp;</p>

<p>&nbsp;</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Login" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72c20b3d989fcadd4fd500c4b18d2f432c6d363d7c5e09e15de6450ef2a76bd4c449d23809ec9398dd9596dc1c97866240fd531a0cd5606990932fcb98d514f334f0ca0ab7ba40155d52a75268bd9a11c9432dc2decaf81f2c65de8b74314c5ed0247076347e5b37e2ad32c47feee9e98c9ea0b3c7d41a6feeeee53c23738121aa7101fc97d08c25b835ddffe61b70308a27b45bb870aa10d7e2697f1b80062878ac41aa4976ee051fa4bcddde715afdcd1f428841f7a567f14d2e726008955f47a4105ae5644156c521a6023e5ea3d6f758cde194a7120bcf25ea63be96eca1561da5d0e2ed6244847578c33c415e105ea84cdbf758b6bd50b53d81768376e39428dc393707cf45076f50c8b5921612cd6d216bacaa0bf1d7271501d8e83ec08f587838595d5db189700d314d70bdfd06d0c1b6a02ff539e981c352b15dbfcb5953f16d052f8bc7203ba4cc7ae73ba78cae2bf1e5a6138e418ec45d54885930b8e86ca7568657bb1bab9200bfd58cc5fb2b53ecb22761bbbc4ed6fa02d13678fc66a627d3801214bcf307c9e9be94efb8d1a09eb1f2a974001164ba56f99815aae55d51a27680a7c8c72ddc88ca69614ed072b4658bcc1669e1ad35e26ef41a3435c9ff2468089cce805f1acf0a19f7928463d9e91dbdc2fb1581616d0c6091c1e093b7c8fc9a7c9a90abe8eb52344a0ed094e378cec32bdc1619675629247661f4d8065c09fdd59c869dc68f2a430e1612fba0c2df0b0ace15d4393a301322005e9dadb00900787b945c94dbb758a6a08854d44656ab86232dd1e4933592f00c4233b577c60806231a8ecd7e1a006aad5f92b453872d2b303369eed13d260597e74696bfde992c5af5752115d2b79af9b5ee05e77a0117c6318764b9f48f7196c0170031796b078374ad9130e932167eb12b0445da7327507098b980be3521cf10a745581a5c021330f38548b71b125031cd7d5343f96b73477f8cbe1a6e14d148e5ea0b96e72a8ff01fb51dd208ab789c489e15576c5c585af12258bb93b26d0071a3aec8697fa3a0d0f007b515ad0e4f09821f581e4103f7e4d778a1379cd83395772a26d1f64fc967404c391933bd46fcc0bb9c25be74fdf3aaa5def312f31287d00715a4cdf7baf379f1c562f9c6bb4cd69f525f949e2f3ba548fe3d09c6a61341512bbdde650840c37d308e6da3232ed4d3a1d9db3b5430dcee102c330438b997e59bcbf72ca464ad86c173594f014790e91f6455873dfb4a9a14c20018891afb0d830dea5b939b9917aa3643c92103a08b0ebe2489dc9ac761490c3cbbc3ef8f1061091ebcf483fa48f2dd5d65e8c4588a4fb8748cf941a0be832339b2f4fad16bbb86a47554bb170dfcea5c20d5bf244ba5118cb59fc226c5269d19139cddd9540b9c062788a7d9cbb34e9daf6859140b83af13a9992f6db17f215ce2456290ce1b26030256975ad732bde7fb8979315d8e5165ee74f9ca87588736f8b0706ecc3f20a179878c6e17d49318854ce9cf959ce50dfa2f78cc8d17a2452c6d116cb0dd1df6b4179e319cf8354fecb9bf60c1fe6760c035c1f98836ce9f98f758b5825a3a7c1f5b38df8e12f0b4ea8b1aea9aa64e6b3aa7558583d440a3a704288a1f77813f9401f7ebd6e889ba57c1a19bc617c68d5f885b3c52eb4e8aa63e2e3c43ac75ff422128e82907428e836287aa6458333ea532766f412859991afeb9f1f98a9de06441cd4a141074a3db14ba7b03faa746c105a3e9305ba0a30d1cae5394dbbb1cead7386b158077499e545acab34b0fc5d0455ed38af711a0659671b005d5f76884ee801bbcfbf6cecea2c7a40360282a294a74ceab5f9810636e57577571eccc13fd05e29977706449cc5f48828c7dce3c2a0ac633041c4273fdc4860038595e5451dcc6687280dedc954ff4943d823bffe60c2c991a77f0857cfae9314a3c3e74054eb1e95b4fa733d529438b40f4e70569a777e9a13bd09d99d50be6b427350dbec8ec7f528c102e5b4e36f81dbb4fda4eafc877a9c61f1e78f7764cc71c62497be7ca0c65728cc4a61bd425137069ce1a6409324b28b2b9cc92e0847fc7de7b4e868649f23c7cabaaea5da9d467a83efa0562173e4a303d81497cbdbfdd65fda7490ad1b7c5d261349c6ceaa72f148d70a94a605c1a79103e0ff4e2b640f562fb74a82d6dcb8100c3a3b8f4c587563d7729887c015fda12985be6df82664bba91d772d0cf76a42bb3849a9f1f963d4a845d746e627c03c1b38af1c45e7999a95674f46fb6a2cbc5dd6a95be2579c0c98545f6c60926c5f9a1afbfcdc499bd9e6eb78bc5e975eaa30f55fe7e94d55d8a757d3fc7af3d9b3dc6d2b18cb5f4f8ba66504677f03474cad33d82149a47fb5dd04e18bc4608cf3dcdc7652e9d3884801dbd25a7068d20134608f37deeb78407dbb27a2fa3d9cac1e35c48800e646f13ad4d6ba0fb507f4cd43a00ea15a46ecde5acb1a36c052b0451a1512c02f6861e96a9954a4cb1989ae3ef52cfc4f25329a7aea62068e5b072965a4eb9ba668924167143e6575427500ee6715685d5c7a5a5b9742f0e9d020df820fd151c55eab8abd75d19a7d7a8a59ab4c226cba28dc3a911f5e5c1e989f1679243dd91b30a3d1cd90a98e9293797c4424c530e587fb3cb76b1d0970d9c579381ec6d730fa782d0dcf8bc79d1652b8cdb0b2c467cf9094f19b23bae5760c2a00341725ab337ab918f028dfb246e7a233c4585bfb448b8b520f3944fa976ade1cca6651494ec0d8c5f289a078894fefb1e2c87567f2e2938213e2424caad6e897096749037553e2c7576fae705630913ce96d5676fc6af6c5e1dce7e508803600e2b5df87b5988fbf040768ef223c7719149f22e13c6cb3b6856d0622eb8fec994b06e66ec319ed85427bea4b0ad806a97213619ee9ae37e5fed84087fe881a3a8e7ffc5487397499b6243a2261354f9d16483fcb1d79bfb92e5b1fa1e3998ffcf42d9fd5af2222c4f3a04c98da4629269af7ac27a32c382d14758639fb429f55d564817a27da33d29b4a3028054ed2035a5e2324b770fe501cc2f2c5f6e39ec0ef134735c9f8fb6e73c223d0739b0985cfd82446a81bb4eed6b7b4b29864f717d360e327dc64b0ae6839c3b5830251bfaaab039b67257c5ffdc313709e591bbe10cc93bddca87202021cce731f76aed4f1b4eb725e27d2a83e612688275e2d3312eb39171cfbe51c2ecc268457a8d5f5a70776311389ec42fee850c88ae400770f45a2e9d1f3420ac6dcbc28bde2971a05ea08c8f509e3c0fabbf8499853f91be7356e0311e27a337637c58e998529a2da9500d1312ebd2d9451d5d12ca28083a7cb1a4cd66af791b80587616f4dcface5aca209c9766a173865e1fa9c5944fe493fe7cc0aed8690ecd1fe37a82142ce92efcba4e2228439f8d36fdd112dd4a898ff8b1fcd3da4f22d53fd86eea74f6ac8f3a55fec92502b243d9a67f41ff48e2795ea5413478767d98e869ccc5b81e416eeacce00535e822268a8a85270501f9b6651b38a158c61e1e68b66a86c1f329974a23669d3cc75045ce89bde63cd9219bbbd23f8bd5bcffae3447726930ba1a36b8c0859cb54d91d71f7804218bd4142847b6607126dc3832a244aca25f798e1e6f25e638d6c1ff9bf9fc8bc7822dbe5638ea7a51dc4d6ce002c18a181c97988e3b973ace16e7e8bfce301acf18402bb0e0234cfed033e9c5ae0d3fcc78ee7298f5dab8ed0642fa5f4091c4c09658cfb17c3895ae074db6dcaaf2e135b4d8d27b0fe182199685e1ac7695d0755a71138fabde86cc327077554ce13befa6fd1c64cf20f0a64cbc9148c1a8dec05c837c9eb450998efa3dd62b427c64b789cfaac1ebc0529f765526c6fc385889f2be7ff69c44ae2a9dd2709aa540813df8c58baab5ab39016e887cfa50494c8dcac71725affe1f3f9e6b254ba282bf5136d0159ffc11bd423f55237c3b130fbfcd3d853ae7a501972ab57e0f83186497c3ae456f7f04c85d03be1b85c3c4d136108ae755ee41be6e0813521a767dbba2c677d86f11f3b4ecbade6858b118910d58ced9f390196617ccf5c5af9b4cdfb495ec6468371f5629f53b6ad78338bb12edbec7315f8efc8df7219c392ed5a4a5748f93ef247b69fcdf9c7d0afa415bff8dc7d51f55dd221c11bee3d3577acb3ade3f025438fe6b662ea5f10f59ecd169bc8a511f86976bb9188434531fffe0e578c17cb0e9d8cb07bb7d5a6d9c53c124041c2aea24e8978e4dc32af8aee8c8ca5bf1357bc369a3698a6394235d3f9d4326eb104b54cdcf7a2f917d57777d446961448361749e3853d49395e1e1c5687d2a87dbbf2c6a3739ba460a3d76d9ce19020c36658c38c1b2d04822fa3099dd3bdb742badc1e30293cafb9f4a4d3a9692eb4fd697bb203999c0ae21de5df3de898b9116d3f1d3658e5c9cdaa3d666dbc8851c11a1642ad8a13afbd47d52fa1996f18304d6e0dd04bed569cfec61f0f44a203544f5368a1f5b8127828cd061feddf4dfba4d9f1c2d968123df43b5358cf4617a82a8ef12787103f30c08a0e78fe5b10292b1c394ef4330ffa5032ab356f882967f84beba5b986a264f45231bb04215e4c616f4bfb0b9a21cd3cc50d995fe2a280cb2cdf3924d401315b2644a2bb3566abfc5f2bb230c456d8879f97ea522b1effb269e4546e806bc24075d987c7a8746158181582fe5c692cdfb8d524edc6af7f3437dbc8fdcc2a01c8b5be66face05812c46766514a61bbe653a28458ba16f9219ecbd8a1d7c27fffa5634f23861a705cdb7a3fac27cd4993b17342b01f30f28cbe63481bb3d61b04f59a4fadb87ed18e2a2cd2d222f728bc6e2c0950da0ca3d86577015c48198b5dbe04d01ee243f5b813922dea57a056381b4680f92871f4ab6d629e5dd25aeecfd11a321f0f05695f47fd8128bedfec0968a19cdd5f73842123d96eec14ed339e76f44de094a7a6b7d57dfc30498d1c6e1a9562b135acea331fe44483e6d1df62e31549c9e39f49b7e6be056de2758335505fdd21a9bda5c3c1c1e2f7d6f13fbc9c5eeb33ea8440d8467527ab9d423cea577001142f08e30c5f5443d3454bef257b8126608f8dd3315b1d2729e3ac67bd3562303582d999d0ed18f899ed87865336905131362ed7f8a73679280e92a7d870fc82393aa533dfdc892647ca7c476e068d0e4d87d6333b2d0006a4e1c50d7c1256b0e1f01d4ce471ff4a91b992112153e5231d76b5ef1080fe196e339cacc1b2ff7833d75f2571e057cc3a163edb2ca1d932c6442421b539b3c165fcd7848d1dda43a5839a1b853968d9182b5b60c8cfcabd9073e249c9d88cecec593c9b390bbebcfa3786d04e376a4505aa3d61dd21bc77b1dd7aec9f609086f8d985c81c722ee9bb2177800b5c3e02f05125e030f3fbe0d14e87653b583a74720669776835a15f593e2eda1172355a4f9ef4f36715081143968b04dc99a2986efc020a80dea48faea63d72c868641ace97e22797c30557d6839af6cf6ecbfdcecfb545e5422d102eaa47650d7d56caaa0c065d3bfe3aa5c578593ea31465d435b274c710630ff7f497c9dba246c0d024e403c457130b597cda6d66a934fb7cb60b392fc4e0d6a49a582e0e2c960b333f7247a1ea05dac38cabddea9044ffcc020e5321896da1e0f6b6f2f56df7b2458095d02792a0e2dfd96291792317d544a212c8933d8774c752c305d5235e4c1ba5d4d1259e1929e19c5323185bf882d5f78d83788b7a496c3ada9ec99549f5b24485d06500f0665de971401810ffda7edc48d7877ecb71ae6929e3207d3457a113480dc84436b03af277567ca365ab562b4dab5b547440a0c0cb669d5c6fd896193e36f6e1dda084aeb72db3fd26f46caee3534fec1deb11d3bd9e5d2f381c1e9ef3bec1df1774bd1ae63eedb92cf8a88d61590cfcaeed61aa51ae8bfe1552fe80e76efbba4607470f1d990999fe79ac66583bda9aa15e8e7c018b142045296784b039a71d6964c529426f790b3944fcfafdd398aedde3daa218c858c6d4c6909d1d7115bdcd08380ad8432869a308ba94798b27803836d403a2c9742246fd89fa93341da58dbb2d8b9776db67786eb07174e79b4601f168bbb2dbcd956357a51b279fa9d36896d8d7ac1bdf086cc72f1d8886305f3c2e27ed34203e9fa4e33c3f5089f037c095cfe7781effb5ea9542ae7f30167bdcdea7e8dcc05f1295527d7baa36e9ab35e841329e25a13d7796b174cf01ffcd0ceddce5a4936627026bfbc9b0b8d93a70212ac1d3aa251b99f48bdcc8878fa696dc3734f451b5581d02ef5d75ae57687855038cb235ad68b68a7e8a0cf921ed5555ba53ab76bd8d2311cdc2a90ad0f450910bbe3df0df98836de5cff63960633df8a56615439b73fd5d7b564e274bf2f3f5f697726fb449813227035d9989dd4eea3cc8d398a06e50c9616cfba6dd6fff9d4f16e824f0c799249d5690771a62f8fdd61e5ea4679917b5f335c932c10e59ec84a8c0b5ad57274eb82d61b6b24496f5da36b142fa3f75de16cf3aa48f83d1a8c006e75cf61d607dd2663f5ea0c7ed3e7ec895b4276edd997c1833771011b3f440d5317ab66908e030d0a10e358ad7cf5f1b6ba97d50e32f5c629c1c6fba3699d14e8489f38c5656c99eb41c4b14c5d0332638a228dcbb1f9dd5939e31b2ad980291db8459867101b5516b8bf5b83faf086428535d685f12b93486466b9f4a247e882f6c43a9c666b19de0f8bd36d91fab9a5afbf3b140a19701e9996858bbd447fff4b3d9052ae1c7164e2dca665c0698344e13efa41f35f51b85d3b0b7690aeda24c4ccbb3bb54ffd61aa9f3fb752922127f503fc48093e9c8a6b55eb55400e98f4b4cb314e1a9bcaae44c1c2336e1ab857c36389325df14f6dbf65c10c3d5b235ebb7cc18075f312e044c56308f590a04df2c42637436c821273f2463979f22027654f54cb4e386ca74e361b140dea3b84c41ca89e9fd794fc5e21792e38258ffb02bd53848ee42528fb4845f5b4aa3365c5542713e1445bb4e170394a397f2c057f367807df7716ee4d80dad76a0d651132685ab24a6fcd9b83ffbd0a629a8a2a6d73818975643c6b6e1b126fce11107497481db879f912648673a09168e3d25cc48636ebe7b05c31af6785644416640f8c0f24b6d70d50a9374daee477d8fa379813664e1d1b959b6f8006f629bb2cc052943c500402f2de28bf9c6bfd0351900141d028979cfa8031050e5c72a943f764dcf7f8443dc642f96a11c68222d716f288368746a562d1bf0196ed9a2500e7cf4adb2599ef50268fa353e452269c9898697c081a11c532cedea219ff0ac0ff0dc17c7fd4ed8e8522a97ad4f0840a9c9cd63d19fc00f88063cfb67c8678eb9c0ad8a2d9f7401ccde679adcb72d39100b0bf4f6c39aea8c6c0c94ce7342cdf8f939633ecea4d99ba084e3ff489bd125db28a37bab0f404f22d156c98266ee099576fa0c46ee39dc885a9b76eec2692e546c448f6dae5de4a6eb3a8cc52903e5e9508df4a9949166dc9f5b96e85bab47dab24afdf507e80cace1a63347c63382c90224870b2950b58296bf7f8fafa1b94d0e295e5074cafd87e6a0c8b3d46d59eed99308c913d8426cfd9404a32e3503bfd39da6ae1f34ecc336fd92c01f7b7ab74e721317ad5f0ba787eff4737e5fd73d43a3d45d6be439b86cbe3bd3f919600edc725a429c94924b7de4e6fcea7f4f6140f66e8a8047e7ed7d038f4c0dbd3340ac36e35c1c438b4133986e1fccfcdd1acfa398e14ebe58db3b530c118ecf106ed7bc65ebec398ea0a0305e710e6cbd95a04242d3a9cdbb9d235e026f3f8e861f5212592d99780ddbf3efee5b9da0bf4856032975f59d629c8318fb78f280fd515d4d482c8e301f51d87c83f2959fe9a9cedca937be3a87fd29d122ba7672a9902ca6e9bbe889e911caa68ec489774e15467ba03d084349a91576a5a27df5dc7927f140de35c6032a0a889b11e713695ac870bdf28a9d0b7c5956757c5a4553f9e882c815947abf8957917ebab00c296f235e4619e583f8425ed307af67ac34246957cfc88e2796d20d5ba46582e9734c25d3806b6bf8b6e06d00b1b671f93de5e47ab84def786fea62387c425030f598df8c8147e05441b84b508f1192ea24eb6259da8cae8ec5b2d78360068e42293600b0c2ba413c3c9fb207e5644320b1a27106baef2e8b0c478284882a349179a679848410c109b1dcb4de7f30aaf2a4f09fd1cb149a01cd058dd3bbc48735aafe1c65b639f911043904ceb40fcb99696cf8eb506d65340f28a1696923a5dcfe2205f5dbf009144309601d91319c908057868a7a062040897aa76a80160cd1f5d22c51c4c5a967f323a94fa1aef5925182b01c0ca87dac59a729fc88416483d52259d7b0508b6bfd4e2d7d8b21e13542b1c408f3586852dae420fd216a9fcadaee1126762bc270624cac30661ece2a04f48eaf8902c52f124424ac0b95523fc9d8f26ed407503c012e4a68094ffd7db04fa56972e07409061d74f7d653764dfae184a62432923c01e71d578bfe43bde0456486419c70caa7df0f8dfb79d1aa69cb68cfa775d5762cba8272322a9b0eeb69a03ab3f40bfa60dc6bfb6c365d97f721d92c15fb22cc1780b6fa756e1534955e7332c63f54035a88c6d532d9f190865ac031389ff64b36cd166daff339b9ed6b179f35bbcfc7c565d5787a82e07ebf9fd3627e1a3a6cb404eb031b3a0e42ba32004031e7ec5a18f67ae779f8d0cefc1e11406acc747536aa872191ce0b344d69ac16c7173285db807ed8db130ed74c005f33ee543c0e033d361709fd8ad7e5ee3b79b166ba9f1cd48011f5a0fb183d6e4bc480c7d2da04db74d2c0263d3862923917d6daec90c88b6f405d53b364e4d779e121a14d842cc6bb4191654faf5ad8c5039f170102d709b59f22a24a9778ed7e5e803664331210c6ba6b17a20057872c1312a5df9cab2a020e92ae89586fbe304b9492c46e01371cf0ab3a0f3a90bbaa89d51ce1cb96b48c9268cafe6df855fd2dd092ffd988d4aba48fa5a63c6e7caa9c0455654cdd2b115e72a44d0fea476e7d36df117d2d4391beaf64eb70cd0467b69b4361ca6c423436522979e41d11b3f76865127e30ff2234438ba5e279e308d4152d8fbeecbc296a510ca9ac4660a738b51bd6fe8bc8870664e1137f6db0cc3d48de1e4cd229fd83cc4377deebd387806378308403055e15b1259e70bc8e9ef5c6ae63e6fa2ba5189abae744152a95cc1e9cd0eb1a71bb57133c65c584d46707683877b6fbfecda4e72b7c1111edc424bf6f557a1288022cac8308d03ff22097bb520c627dc7f489aea29fce26dfea95fa606c1710d521ba4dc963a63b6d77d3faac132223cfb63e5eae8a897246cfb111a4a8d755cf5ec1efee20ab8b67770ae5a9b20f6412a52530a12f905c69e86bcd068e8c9a210339112e58900e6af18567450f4f1787b3be3e4289eb53f3493e3712407194c8873d7c0bc164cbdd37e5a58e01e44d0fdabdb77ecbb49ec42ffb89130e4a6305cd8f6e43d39e54382c99dac864ab0fb745c138a34fa771e50726f85e070e981cc68033179f3dd70a67bb6db68ee954c4f553bb96ea5ba01cd0954e4feb02463a1267505e14fa49600fd612feb717c4a61620e0eabbe6bee666e69a354ef40b79862052c1a2745e251914c8f965099ae920d99eb11dea91e452087b41d97bc3c9761a514d337bb8a881fd0247a4fb61d1719cd4d5b25556fdba802e39ca3874745b7afca49beca9ef16bab615553a2062dd3cd2f97b9126f081cd368477af9cddfa2c36ab4d285e2f49f756448c9622276b3b88bf0a6293e6f2b1d2138947857738902a03d0da77a5aa0b056944faec5843a14f4be270c368dff6b0078163fd8f26b62bd6898d469815e4280e579ee0be3cab6ddd7e0d88af105a831aaa9033fbbdb80a5469a403c5f54b88645aab79595eae1447d863441f185f1e243f1f8a4772f3b289202b8131b7a3d30dfc681bf52ab2bac98fcb997c9e9214e0a02982a6c101dcb0a40df3b5264ec18454bcaf89345c9547f8e0c688e919229fc1f754a2132d527f0f8c0391d1a187adadcc758817911e1a8e1b9ec6eefe844409665af2616ddc52d8b301308f41120c1dc4d849f94bd0e9c7bba3aa5ce3ad223b11b3815108a58ee20654176f3b14b5e6226a6e0cc6655cac6428f649383e303c1e54810ff27587861911b2950fd170b929c86a21a6576b1335fe859c2b171e6e7d4ea0a13f6aff07747e9b59a1b59df17db140d0b1f2aca3cb14e538c7a96966c1f313ca818da2df3d535e328404c9104227e3d05b13f0e87572cd8938c2a91bbc2c18e63712f494ce3cd5dcf015a6de932cb41a25b240e2d2d91a057d97e01ad02c459af096d416a505f31bc0c06671cf58dac33060519de3566e612f093cebe18fc45f50e751d3c7cab35b456d4ce94d26644288df9e75a023bb4c317aa93fdccd4c6a9808b90c7e7446d83cf457d4ff59e074fa99f6e2feb9a317eab389ea307d442db1b4208b5176c965b044c7c7b82ce8229bc4f2219b5f6b1da17d589243143d131224680506ab859e7896284506047966d7462aa152bfeca80cb0660994cee556c5bac2d0a188d9aec2a15277197fbcaccae74e42fb77ac0d9dff6bdbf2b4da2f074ed0655d85a0ff73a2fa9e766a5e49c5da57a865714d0fc14a848fe106ced65670465249d7bb21825254ebc5d89d20f304b41f25f76c168df09abfcc3a59edcaf6a9756b688cfe98389a2db069a7d1099dbc0c769492eef4c6ac4e60239c2e8041a662af41107fe1a2b18a5d1bb47a2d3fe2853982e7c5825cd136fa9f9db484fa891dc3867ac4a1705ac33afae23a3a2b7cc31574826798882fdbf2b9304035a297dd688f2e444d23adfb3965a4bf85c186b6582825cfb53d625afe23c39951f70a0c4c9e02263067e684a111ac1f19ca0cac18008b73f0db9650e124329cdc94a6434ddde9a098bb8616ff2b0a3c892ace6e1002b6ce00fb912dc1951d48d4cc2e8d3afd64c079eaddd2d6a880283b668fbdab9ab8be738580c0c6ef54adac250eb2be6d0af0d9c156590e33920d1a2a651ffd796f215c09d193fd12c29eb8adee94d180964bcdf473b8c11e097696bd28492843c1d45fcba1f50dbf7fe92e3f031f5b10e2d2963c6f9d2189f4f260a8de13a9344b152e18d718b375ef13ff3a7fd6a4e8728892338267e63326738d525a9ffd2ed4f3f7efecaf2f02fbddca8578990d31209388e3cbdb05ddcbf9cfef39ec46f1a4f0d3779a10ed14f4dd4905980d7a10095325f57efd15b8a76464f968cfe710cbf317ad6dde79435175defc306861032320b8f03ad51a40500c0633d680358cdc4ebace383488587823614053dec5dcca51deb88895b12dcf8d062735293fc374f3655defbec5556511854168eca68ce4525145271dd462344f4a6cb65787408a9259bc4113812e6ec4f653c071b73a608c5c7d385947f6e186241aeb3ab6a471ba4b77af168561e51eafe95f40d448e6e7a059504efa6364b9a40ceb160e8aada3ff791220ef8b7197b897e8e5b86bf569aa38a0361f3a732743b4fb38054555cf75cb8ad89812edc25975f5680b413b994ec382330523bf132e0c4889b23bb40662fa54e9a82cf01f5c5c937c06afe74fce7ea151bce72a555eaba3f50a9001a6ebcd51fa6dfe36110e151c23f180ec8873c7ac65ff2770676cf7f3c5eb2e530e2ca90bc6f171c94c3a0dc12cc7dd9cdd07b6d0484fa8cde76218fadac5d8e2d7a28a7571c515fc8bacdb30f37ee70ca9d3e19315a461c2bbbb208c2853d170","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80307a76eb810be0f3cf43e96e0ed7f1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
